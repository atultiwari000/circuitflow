
import { CircuitComponent, Wire, ComponentDefinition, NetlistResult } from '../types';
import { COMPONENT_LIBRARY } from '../constants';
import { STANDARD_MODELS } from './spiceModels';
import { getModelForComponent } from '../simulation/models/ModelRegistry';

// Union-Find implementation for node connectivity
class UnionFind {
  parent: Map<string, string>;

  constructor() {
    this.parent = new Map();
  }

  find(item: string): string {
    if (!this.parent.has(item)) {
      this.parent.set(item, item);
      return item;
    }
    
    let root = item;
    while (this.parent.get(root) !== root) {
      root = this.parent.get(root)!;
    }
    
    // Path compression
    let curr = item;
    while (curr !== root) {
      const next = this.parent.get(curr)!;
      this.parent.set(curr, root);
      curr = next;
    }
    
    return root;
  }

  union(item1: string, item2: string) {
    const root1 = this.find(item1);
    const root2 = this.find(item2);
    if (root1 !== root2) {
      this.parent.set(root1, root2);
    }
  }
}

export const generateSpiceNetlist = (
    components: CircuitComponent[], 
    wires: Wire[], 
    circuitName: string = 'MyCircuit',
    extraDirectives: string = '',
    customDefinitions: ComponentDefinition[] = [],
    valueOverrides: Map<string, Record<string, string>> = new Map(),
    enableInstrumentation: boolean = false
): NetlistResult => {
  const uf = new UnionFind();
  const getPortKey = (compId: string, portId: string) => `${compId}:${portId}`;

  // 1. Process connections (Wires)
  wires.forEach(wire => {
    const p1 = getPortKey(wire.sourceComponentId, wire.sourcePortId);
    const p2 = getPortKey(wire.destComponentId, wire.destPortId);
    uf.union(p1, p2);
  });

  // 2. Identify Ground Nodes
  const groundRoots = new Set<string>();
  components.filter(c => c.definitionType === 'gnd').forEach(gnd => {
    const key = getPortKey(gnd.id, '1');
    groundRoots.add(uf.find(key));
  });

  // 3. Map Roots to Spice Node IDs
  const rootToNodeMap = new Map<string, string>();
  const componentMap = new Map<string, string>();
  
  // Store the final Spice Node ID for every port key to allow probing
  const portToSpiceNodeMap = new Map<string, string>();
  const currentProbes = new Map<string, string>(); // Map "compId:portId" -> "V_sense_name"

  let nodeCounter = 1;

  // Function to get Spice Node ID for a specific port
  const getNode = (compId: string, portId: string): string => {
    const key = getPortKey(compId, portId);
    const root = uf.find(key);
    
    let spiceNode = '';
    if (groundRoots.has(root)) {
        spiceNode = '0';
    } else {
        if (!rootToNodeMap.has(root)) {
            rootToNodeMap.set(root, nodeCounter.toString());
            nodeCounter++;
        }
        spiceNode = rootToNodeMap.get(root)!;
    }
    
    portToSpiceNodeMap.set(key, spiceNode);
    return spiceNode;
  };

  // 4. Generate Component Lines
  const lines: string[] = [];
  lines.push(`* ${circuitName} - Generated by CircuitFlow`);
  if (enableInstrumentation) lines.push('* Mode: Auto-Instrumentation Active (QA)');
  lines.push(`* ${new Date().toLocaleString()}`);
  lines.push('');

  let compCounter: Record<string, number> = { R: 0, C: 0, L: 0, V: 0, I: 0, D: 0, Q: 0, M: 0, X: 0 };
  const usedModelNames = new Set<string>();

  // To collect probes requested by models
  const requestedProbes = new Set<string>();

  components.forEach(comp => {
    if (comp.definitionType === 'gnd') return; // Ground is handled by node naming

    const def = COMPONENT_LIBRARY.find(c => c.type === comp.definitionType) || 
                customDefinitions.find(c => c.type === comp.definitionType);
                
    if (!def) return;

    let prefix = 'X'; 
    let value = '';
    let nodes: string[] = [];
    
    // Helper to get property with override fallback
    const getProp = (key: string, defaultVal: string) => {
        const override = valueOverrides.get(comp.id)?.[key];
        if (override) return override;
        return String(comp.properties[key] || defaultVal);
    };

    // Determine Nodes & Values
    const typeChar = def.symbol === 'resistor' ? 'R' : 
                     def.symbol === 'capacitor' ? 'C' :
                     def.symbol === 'inductor' ? 'L' :
                     def.symbol === 'source_dc' ? 'V' :
                     def.symbol === 'source_pulse' ? 'V' :
                     def.symbol === 'source_current' ? 'I' :
                     def.symbol === 'diode' ? 'D' :
                     def.symbol.startsWith('transistor_') ? (def.symbol.includes('mos') ? 'M' : 'Q') : 'X';

    compCounter[typeChar] = (compCounter[typeChar] || 0) + 1;
    const spiceName = `${typeChar}${compCounter[typeChar]}`;
    componentMap.set(comp.id, spiceName);

    // Map component types
    switch (comp.definitionType) {
      case 'resistor':
        prefix = 'R';
        value = getProp('resistance', '1k');
        nodes = [getNode(comp.id, '1'), getNode(comp.id, '2')];
        break;
      case 'capacitor':
        prefix = 'C';
        value = getProp('capacitance', '1uF');
        nodes = [getNode(comp.id, '1'), getNode(comp.id, '2')];
        break;
      case 'inductor':
        prefix = 'L';
        value = getProp('inductance', '10mH');
        nodes = [getNode(comp.id, '1'), getNode(comp.id, '2')];
        break;
      case 'voltage_dc':
        prefix = 'V';
        const dcVal = getProp('voltage', '5V');
        const acMag = getProp('ac_magnitude', '0');
        const acPhase = getProp('ac_phase', '0');
        value = `DC ${dcVal} AC ${acMag} ${acPhase}`;
        nodes = [getNode(comp.id, 'plus'), getNode(comp.id, 'minus')];
        break;
      case 'source_pulse':
        prefix = 'V';
        const p_v1 = getProp('v1', '0');
        const p_v2 = getProp('v2', '5');
        const p_td = getProp('td', '0');
        const p_tr = getProp('tr', '10n');
        const p_tf = getProp('tf', '10n');
        const p_pw = getProp('pw', '1m');
        const p_per = getProp('per', '2m');
        // Add "DC 0" to prevent NGSPICE warnings about missing DC value for OP analysis
        value = `PULSE(${p_v1} ${p_v2} ${p_td} ${p_tr} ${p_tf} ${p_pw} ${p_per}) DC 0`;
        nodes = [getNode(comp.id, 'plus'), getNode(comp.id, 'minus')];
        break;
      case 'current_dc':
        prefix = 'I';
        value = `DC ${getProp('current', '1A')}`;
        nodes = [getNode(comp.id, 'in'), getNode(comp.id, 'out')];
        break;
      case 'diode':
        prefix = 'D';
        value = getProp('model', 'D1N4148');
        nodes = [getNode(comp.id, 'a'), getNode(comp.id, 'k')];
        break;
      case '2n2222':
      case '2n3906':
        prefix = 'Q';
        value = getProp('model', comp.definitionType);
        nodes = [getNode(comp.id, 'c'), getNode(comp.id, 'b'), getNode(comp.id, 'e')];
        break;
      case 'nmos':
      case 'pmos':
        prefix = 'M';
        const nd = getNode(comp.id, 'd');
        const ng = getNode(comp.id, 'g');
        const ns = getNode(comp.id, 's');
        nodes = [nd, ng, ns, ns]; 
        value = `${getProp('model', comp.definitionType.toUpperCase())} W=${getProp('w', '10u')} L=${getProp('l', '1u')}`;
        break;
      case 'lm741':
        prefix = 'X';
        value = getProp('model', 'LM741');
        nodes = [
           getNode(comp.id, 'non'),
           getNode(comp.id, 'inv'),
           getNode(comp.id, 'v+'),
           getNode(comp.id, 'v-'),
           getNode(comp.id, 'out')
        ];
        break;
      default:
        // Generic / Custom
        prefix = 'X';
        value = def.label.replace(/\s+/g, '_'); 
        nodes = def.ports.map(p => getNode(comp.id, p.id));

        // Auto Instrumentation
        if (enableInstrumentation && def.category === 'REAL_WORLD') {
            const instrumentedNodes: string[] = [];
            def.ports.forEach((p, index) => {
                const originalNode = nodes[index];
                if (originalNode === '0') {
                    instrumentedNodes.push('0');
                    return;
                }
                const senseNode = `${originalNode}_SENSE_${spiceName}_${p.id}`;
                const senseV = `Vsense_${spiceName}_${p.id}`;
                lines.push(`${senseV} ${originalNode} ${senseNode} DC 0`);
                currentProbes.set(`${comp.id}:${p.id}`, senseV);
                instrumentedNodes.push(senseNode);
            });
            nodes = instrumentedNodes;
        }
    }

    if (['Q', 'D', 'M', 'X'].includes(prefix)) {
        const modelName = value.split(' ')[0].toUpperCase();
        usedModelNames.add(modelName);
    }

    lines.push(`${spiceName} ${nodes.join(' ')} ${value}`);

    // Collect probes using Component Models
    const model = getModelForComponent(comp.definitionType);
    if (model) {
        const nodeMap = new Map<string, string>();
        def.ports.forEach(p => nodeMap.set(p.id, getNode(comp.id, p.id)));
        
        const probes = model.getProbes({
            componentId: comp.id,
            spiceName,
            nodes: nodeMap
        });
        probes.forEach(p => requestedProbes.add(p));
    }
  });

  lines.push('');

  // 5. Append Required Models
  lines.push('* --- Standard Models ---');
  usedModelNames.forEach(model => {
      if (STANDARD_MODELS[model]) {
          lines.push(STANDARD_MODELS[model]);
      }
  });
  lines.push('');

  // 6. Append Simulation Directives
  if (extraDirectives && extraDirectives.trim()) {
      lines.push(extraDirectives);
  }

  // 7. Auto-Generate Probes (.print)
  if (!extraDirectives.toLowerCase().includes('.print')) {
      const uniqueNodes = Array.from(new Set(rootToNodeMap.values())).sort();
      const varsToPrint: string[] = [];

      // A. Voltages for all nodes (excluding 0)
      if (uniqueNodes.length > 0) {
          uniqueNodes.forEach(n => varsToPrint.push(`V(${n})`));
      }

      // B. Component Probes (Model-based)
      requestedProbes.forEach(p => varsToPrint.push(p));
      
      // Fallback: Currents for Voltage Sources if not already covered
      componentMap.forEach((spiceName) => {
          if (spiceName.startsWith('V') && !varsToPrint.includes(`I(${spiceName})`)) {
              varsToPrint.push(`I(${spiceName})`);
          }
      });

      // Construct the .PRINT line if there are variables AND a valid analysis
      if (varsToPrint.length > 0) {
          // Detect analysis type robustly using RegEx scanning entire directive block
          let analysisType = null;
          if (extraDirectives.match(/^\s*\.TRAN/im)) analysisType = 'TRAN';
          else if (extraDirectives.match(/^\s*\.DC/im)) analysisType = 'DC';
          else if (extraDirectives.match(/^\s*\.AC/im)) analysisType = 'AC';
          else if (extraDirectives.match(/^\s*\.OP/im)) analysisType = 'OP';

          if (analysisType) {
              let printLine = `.PRINT ${analysisType}`;
              varsToPrint.forEach((v, i) => {
                  if (i % 8 === 0 && i !== 0) printLine += `\n+`;
                  printLine += ` ${v}`;
              });
              lines.push(printLine);
          }
      }
  }

  lines.push('.OPTIONS WIDTH=10000');
  lines.push('.END');
  
  return {
      netlist: lines.join('\n'),
      nodeMap: portToSpiceNodeMap,
      componentMap: componentMap,
      currentProbes: currentProbes
  };
};
