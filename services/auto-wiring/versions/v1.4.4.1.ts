
import { PathRequest, Point, VersionInfo, ComponentData, DebugRect, Wire, SubSquare } from '../types';
import { routeWireV1_4 } from './v1.4';
import { GRID_SIZE, CANVAS_SIZE } from '../../../constants';
import { toGrid } from '../geometry';

export const V1_4_4_1_METADATA: VersionInfo = {
  id: 'v1.4.4.1',
  version: '1.4.4.1',
  title: 'Structured Space Graph',
  date: 'Experimental',
  description: `
### Technical Overview: Free Space Decomposition and MER Graph

This version introduces a dedicated spatial analysis layer that operates before routing begins. Its primary goal is to compute the **Negative Space** of the board by identifying all rectangular regions that are free of obstacles. These regions form the geometric foundation for higher-level routing intelligence and are later transformed into a structured graph representation.

---

### 1. Free Space Decomposition

The system analyzes the board to extract all available empty space as a set of non-overlapping rectangles. These rectangles represent maximal contiguous areas that do not contain components or other blocking geometry. Rather than relying on a uniform grid, the decomposition adapts to the actual shape of the obstacles, producing corridors and regions that closely match the real routing space.

### 2. Recursive Partitioning Algorithm

The Maximal Empty Rectangles are generated using a recursive spatial partitioning process:

1.  **Initialization**: The process begins with a single rectangle that covers the entire routing canvas.
2.  **Intersection Detection**: The algorithm finds the first component or obstacle that overlaps the current rectangle.
3.  **Rectangle Splitting**: If an overlap is detected, the obstacle is subtracted from the rectangle. This subtraction splits the original rectangle into up to four smaller, non-overlapping sub-rectangles—Top, Bottom, Left, and Right—each surrounding the obstacle along the Manhattan axes.
4.  **Recursion**: The same intersection and splitting steps are recursively applied to each resulting sub-rectangle until no obstacles remain within any rectangle.

The final output of this process is a complete set of Maximal Empty Rectangles that fully cover the board’s free space without overlap.

### 3. MER Graph Theory Model

The raw geometric output is elevated into a **Region Adjacency Graph (RAG)** to encode topological relationships:

*   **Nodes**: Each node corresponds to a single Maximal Empty Rectangle generated by the recursive partitioning process.
*   **Edges**: An edge exists between two nodes if their rectangles share a physical boundary along the Manhattan grid. Corner-touching rectangles are excluded, ensuring that graph connectivity reflects true routable adjacency.

This graph structure converts free-space geometry into a navigable topology suitable for routing algorithms.

### 4. Resource and Capacity Estimation

Each node in the MER graph is analyzed to determine its effective routing capacity:

#### Wire Occupancy Analysis
A full segment–rectangle intersection test is performed against all existing traces. Regions are flagged as **Active** if any wire passes through them, even when the wire has no vertices inside the rectangle. This prevents misclassification of pass-through regions as empty.

#### Square Decomposition for Normalization
To normalize routing cost heuristics, each rectangular region is virtually subdivided into square units based on its shortest side length $S$:

$$
N_{sub} = \\lfloor \\frac{\\max(W, H)}{S} \\rfloor
$$

Each sub-square is independently analyzed for wire entry and exit events, enabling finer-grained estimation of routing load within large or elongated regions.

### 5. Visualization and Usage

#### Visualization
*   **Amber Zones**: Indicate regions containing active signals.
*   **Cyan Zones**: Indicate quiet, available routing regions.
*   **Sub-Grid**: A dotted sub-grid visualizes the internal square decomposition and highlights the granular capacity of each region.
*   **Inset**: Visualized squares include a fixed inner padding to demonstrate safe routing corridors.

#### Usage
This system acts as the precursor to **Grid-Based Region Routing**. By understanding the true shape and connectivity of empty space, future routing stages can guide wires through the center of these corridors rather than forcing them to hug obstacle boundaries.

#### Animation
The partitioning process can be replayed using the **"Animate Space"** control, illustrating the recursive decomposition step by step.
`
};

// Use v1.4 for actual wiring
export const routeWireV1_4_4_1 = (request: PathRequest): Point[] => {
    return routeWireV1_4(request);
};

// --- CORE LOGIC ---

export interface Rect {
    x: number;
    y: number;
    w: number;
    h: number;
}

export const intersect = (r1: Rect, r2: Rect) => {
    return !(r2.x >= r1.x + r1.w || 
             r2.x + r2.w <= r1.x || 
             r2.y >= r1.y + r1.h || 
             r2.y + r2.h <= r1.y);
};

// Check if two rects are adjacent (sharing a border)
export const isAdjacent = (r1: Rect, r2: Rect) => {
    // 0.01 tolerance for floating point comparisons if needed, though we use grid ints
    const isHorizontalTouch = (r1.y === r2.y + r2.h || r1.y + r1.h === r2.y) &&
                              (Math.max(r1.x, r2.x) < Math.min(r1.x + r1.w, r2.x + r2.w));
    
    const isVerticalTouch = (r1.x === r2.x + r2.w || r1.x + r1.w === r2.x) &&
                            (Math.max(r1.y, r2.y) < Math.min(r1.y + r1.h, r2.y + r2.h));
                            
    return isHorizontalTouch || isVerticalTouch;
};

// Robust Segment-Rect Intersection
const segmentIntersectsRect = (p1: Point, p2: Point, r: Rect) => {
    // AABB Check
    const minX = Math.min(p1.x, p2.x);
    const maxX = Math.max(p1.x, p2.x);
    const minY = Math.min(p1.y, p2.y);
    const maxY = Math.max(p1.y, p2.y);

    const rMinX = r.x;
    const rMaxX = r.x + r.w;
    const rMinY = r.y;
    const rMaxY = r.y + r.h;

    // Check for overlap
    if (maxX <= rMinX || minX >= rMaxX) return false;
    if (maxY <= rMinY || minY >= rMaxY) return false;
    
    return true;
};

export const recursiveSplit = (space: Rect, obstacles: Rect[]): Rect[] => {
    const obs = obstacles.find(o => intersect(space, o));
    if (!obs) return [space];

    const result: Rect[] = [];

    // Top
    if (obs.y > space.y) {
        result.push({ x: space.x, y: space.y, w: space.w, h: obs.y - space.y });
    }
    // Bottom
    if (obs.y + obs.h < space.y + space.h) {
        result.push({ x: space.x, y: obs.y + obs.h, w: space.w, h: (space.y + space.h) - (obs.y + obs.h) });
    }
    // Left (Confined)
    if (obs.x > space.x) {
        const y1 = Math.max(space.y, obs.y);
        const y2 = Math.min(space.y + space.h, obs.y + obs.h);
        if (y2 > y1) result.push({ x: space.x, y: y1, w: obs.x - space.x, h: y2 - y1 });
    }
    // Right (Confined)
    if (obs.x + obs.w < space.x + space.w) {
        const y1 = Math.max(space.y, obs.y);
        const y2 = Math.min(space.y + space.h, obs.y + obs.h);
        if (y2 > y1) result.push({ x: obs.x + obs.w, y: y1, w: (space.x + space.w) - (obs.x + obs.w), h: y2 - y1 });
    }

    let finalSpaces: Rect[] = [];
    for (const subSpace of result) {
        finalSpaces = [...finalSpaces, ...recursiveSplit(subSpace, obstacles)];
    }
    return finalSpaces;
};

export const calculateEnhancedFreeSpace = (components: ComponentData[], wires: Wire[]): DebugRect[] => {
    const gridW = Math.ceil(CANVAS_SIZE.width / GRID_SIZE);
    const gridH = Math.ceil(CANVAS_SIZE.height / GRID_SIZE);
    const world: Rect = { x: 0, y: 0, w: gridW, h: gridH };
    
    const obstacles: Rect[] = components.map(c => ({
        x: c.x, y: c.y, w: c.width, h: c.height
    }));

    const rawRects = recursiveSplit(world, obstacles);

    return rawRects.map((r, i) => {
        // 1. Calculate Adjacency
        let neighbors = 0;
        rawRects.forEach((other, j) => {
            if (i !== j && isAdjacent(r, other)) neighbors++;
        });

        // 2. Identify Connecting Components
        const connectedIds: string[] = [];
        components.forEach(comp => {
            const compRect = { x: comp.x, y: comp.y, w: comp.width, h: comp.height };
            if (isAdjacent(r, compRect)) {
                connectedIds.push(comp.id);
            }
        });

        // 3. Sub-partitioning
        const subSquares: SubSquare[] = [];
        const isHorizontal = r.w > r.h;
        const majorSize = isHorizontal ? r.w : r.h;
        const minorSize = isHorizontal ? r.h : r.w;

        if (minorSize > 0) {
            let currentPos = 0;
            let subId = 0;
            while (currentPos < majorSize) {
                let chunkSize = minorSize;
                if (currentPos + chunkSize > majorSize) {
                    chunkSize = majorSize - currentPos;
                }
                const subR: Rect = {
                    x: isHorizontal ? r.x + currentPos : r.x,
                    y: isHorizontal ? r.y : r.y + currentPos,
                    w: isHorizontal ? chunkSize : r.w,
                    h: isHorizontal ? r.h : chunkSize
                };
                subSquares.push({
                    id: `sub_${i}_${subId++}`,
                    x: subR.x, y: subR.y, width: subR.w, height: subR.h,
                    hasWire: false, wireEnters: false, wireExits: false
                });
                currentPos += chunkSize;
            }
        } else {
             subSquares.push({ id: `sub_${i}_0`, x: r.x, y: r.y, width: r.w, height: r.h, hasWire: false, wireEnters: false, wireExits: false });
        }

        // 4. Wire Occupancy & Net ID Extraction
        let rectHasWire = false;
        const netsInRect = new Set<string>();
        
        for (const w of wires) {
            if (!w.points || w.points.length === 0) continue;
            const gridPoints = w.points.map(p => ({ x: toGrid(p.x), y: toGrid(p.y) }));
            for (let k = 0; k < gridPoints.length - 1; k++) {
                const p1 = gridPoints[k];
                const p2 = gridPoints[k+1];

                if (segmentIntersectsRect(p1, p2, r)) {
                    rectHasWire = true;
                    // We use sourcePortId as a proxy for "Net ID" in this demo since wires are individual
                    if (w.sourcePortId) netsInRect.add(w.sourcePortId); 

                    for (const sub of subSquares) {
                         if (segmentIntersectsRect(p1, p2, { x: sub.x, y: sub.y, w: sub.width, h: sub.height })) {
                             sub.hasWire = true;
                             const ix1 = Math.max(Math.min(p1.x, p2.x), sub.x);
                             const ix2 = Math.min(Math.max(p1.x, p2.x), sub.x + sub.width);
                             const iy1 = Math.max(Math.min(p1.y, p2.y), sub.y);
                             const iy2 = Math.min(Math.max(p1.y, p2.y), sub.y + sub.height);
                             if (ix1 === sub.x || ix2 === sub.x + sub.width || iy1 === sub.y || iy2 === sub.y + sub.height) {
                                 sub.wireEnters = true;
                                 sub.wireExits = true;
                             }
                         }
                    }
                }
            }
        }

        return {
            id: `dbg_enh_${i}`,
            x: r.x,
            y: r.y,
            width: r.w,
            height: r.h,
            color: rectHasWire ? '#f59e0b' : '#22d3ee', 
            subSquares: subSquares,
            adjacencyCount: neighbors,
            hasWire: rectHasWire,
            connectedComponentIds: connectedIds,
            netIds: Array.from(netsInRect)
        };
    });
};
